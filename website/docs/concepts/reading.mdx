---
title: Reading a provider
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

このガイドを読む前に、まず[Providers](/docs/concepts/providers)をお読みください。

このガイドでは、プロバイダを使う方法について説明します。

プロバイダのreadする方法は複数あり、基準によって少しずつ異なります。  
長くなりましたが、ここでは、プロバイダをreadするときに何を使うかを決めるための判断グラフを紹介します。

![Reading Provider の判断グラフ](/img/intro/reading.svg)

次に、個々のケースを見て、その仕組みを紹介します。   
このガイドでは、以下のプロバイダーを検討します。

```dart
final counterProvider = StateProvider((ref) => 0);
```

## 何をreadするかを決める

listenしたいプロバイダによっては、listen可能な値が複数ある場合があります。

例として、次のような[StreamProvider]を考えてみましょう。

```dart
final userProvider = StreamProvider<User>(...);
```

この`userProvider`をreadするときには

- `userProvider`自身をlistenすることで、現在の状態を同期的にreadする: 

  ```dart
  Widget build(BuildContext context, WidgetRef ref) {
    AsyncValue<User> user = ref.watch(userProvider);

    return user.when(
      loading: () => const CircularProgressIndicator(),
      error: (error, stack) => const Text('Oops'),
      data: (user) => Text(user.name),
    );
  }
  ```

- `userProvider.stream`をlistenして、関連する[Stream]を取得する: 

  ```dart
  Widget build(BuildContext context, WidgetRef ref) {
    Stream<User> user = ref.watch(userProvider.stream);
  }
  ```

- `userProvider.last`をlistenして、emitされた最新の値で解決する[Future]を取得する: 

  ```dart
  Widget build(BuildContext context, WidgetRef ref) {
    Future<User> user = ref.watch(userProvider.last);
  }
  ```

詳細は、[APIリファレンス](https://pub.dev/documentation/riverpod/latest/riverpod/riverpod-library.html)を参照して、各プロバイダのドキュメントを参照してください。

## Widgetの中でプロバイダを使う

このセクションでは、FlutterのWidgetがどのようにプロバイダと連携するかを見ていきます。

### ConsumerWidget

[ConsumerWidget] は、`StatelessWidget` に似たウィジェットのベースクラスですが、プロバイダをlistenすることができます。

```dart {5}
class Home extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // counterProviderによって公開された値をlistenします。
    int count = ref.watch(counterProvider).state;

    return Scaffold(
      appBar: AppBar(title: const Text('Counter example')),
      body: Center(
        child: Text('$count'),
      ),
    );
  }
}
```

`counterProvider`の値がどのように`watch`という関数で取得されているかに注目してください。  
この関数は、[ConsumerWidget]がプロバイダをlistenし、値が変更されたときに再構築するためのものです。

:::caution
[ConsumerWidget]の引数として渡される`watch`メソッドは、  
`onPressed`や[ElevatedButton]の内部のように、非同期的に呼び出されるべきではありません。

ユーザーイベントに応じてプロバイダをreadする必要がある場合は、[context.read(myProvider)](#contextreadmyprovider)を参照してください。
:::

### Consumer

[Consumer]は[ConsumerWidget]であり、データを使用する必要のあるWidgetのみを再構築することで、  
アプリケーションのパフォーマンスを最適化するために使用することができます。

例えば、前に見た[ConsumerWidget](#ConsumerWidget)のコードスニペットを更新して、  
カウンターが変更されたときに`Text`**だけ**を再構築するようにします。

```dart {11}
class Home extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Counter example')),
      body: Center(
        child: Consumer(
          // counterProviderの更新時にTextのみを再構築する
          builder: (context, ref, child) {
            // counterProviderによって公開された値をlistenする
            int count = ref.watch(counterProvider).state;
            return Text('$count');
          },
        ),
      ),
    );
  }
}
```

この例では、UIが`counterProvider`をlistenし、カウンターが変更されると[Text]をリビルドします（その[Text]のみ）。

### useProvider (hooks_riverpod のみ)

[flutter_hooks]/[hooks_riverpod]を使用している場合、[ConsumerWidget]の代わりに[ref.watch()]を使用することができます。

```dart
class Count extends HookConsumerWidget {
  @override
  Widget build(BuildContext context) {
    int count = ref.watch(counterProvider).state;
    return Text('$count');
  }
}
```

これは[flutter_hooks]と[Riverpod]の両方を併用したい場合に便利です。   
この構文は、[ConsumerWidget]ではサポートされていない機能もサポートしています。[select] です。

```dart
class Example extends HookConsumerWidget {
  @override
  Widget build(BuildContext context) {
    bool isAbove5 = ref.watch(counterProvider.select((s) => s.state > 5));
    return Text('Is counter > 5 ? $isAbove5');
  }
}
```

この構文を使うと、`isAbove5`変数が変化した場合に _のみ_ 、Widgetが再構築されます。  
つまり、カウンターが `1` から `2` に変更されても、 _Widgetが再構築されることはありません_ 。

### context.read(myProvider)

[Consumer]と[ref.watch]では、プロバイダを _listen_ する方法を見てきました。

しかし、状況によっては、そのオブジェクトをlistenする価値がないこともあります。  
例えば、[ElevatedButton]の`onPressed`のためだけにオブジェクトが必要な場合があります。

私たちは、[ref.watch]/[Consumer]を使用することができます。

```dart {2,4}
Consumer(builder: (context, ref, _) {
  StateController<int> counter = ref.watch(counterProvider);
  return ElevatedButton(
    onPressed: () => counter.state++,
    child: Text('increment'),
  )
});
```

しかし、それでは効率が悪いでしょう。
listenされたプロバイダによっては、カウンタが実際には[ElevatedButton]の構築に使用されていなくても、  
カウンタが変更されたときに[ElevatedButton]が再構築されることがあります。

そこで、`context.read(myProvider)`が解決策となります。

これを使うことで、以前のコードをリファクタリングします。

```dart {4}
@override
Widget build(BuildContext context) {
  return ElevatedButton(
    onPressed: () => context.read(counterProvider).state++,
    child: Text('increment'),
  );
}
```

こうすることで、ボタンをクリックしても、カウンターは増えていきます。  
しかし、無駄なリビルドを避けるために、プロバイダをlistenしなくなっています。

> `context.read`メソッドが見当たらないのですが、これはなぜでしょうか？

もし、`context.read`が表示されない場合は、正しいパッケージをインポートしていない可能性があります。
このメソッドを表示するには、`package:flutter_riverpod`または`package:hooks_riverpod`のいずれかをインポートする必要があります。

:::info
listenするプロバイダによては、この作業が必要ない場合もあります。
例えば、[StateNotifierProvider]は、[StateNotifier]の状態をlistenせずに取得する方法を内蔵しています。

```dart
class Counter extends StateNotifier<int> {
  Counter(): super(0);

  void increment() => state++;
}

final counterProvider = StateNotifierProvider((ref) => Counter());

// ...

@override
Widget build(BuildContext context, WidgetRef ref) {
  // Counter.stateをlistenせずにCounterを取得します
  // counterが変更されても、ボタンが再構築されることはありません。
  final Counter counter = ref.watch(counterProvider);

  return ElevatedButton(
    onPressed: counter.increment,
    child: Text('increment'),
  );
}
```

:::

:::caution
Widget の `build` メソッド内での `context.read` の呼び出しを避けてください。  
リビルドを最適化したい場合は、代わりに[Provider]でlistenされた値を抽出します。
:::

### ProviderListener

プロバイダの変更後にルートをプッシュしたり、ダイアログを表示したりするために、  
Widgetツリーが必要になる場合があります。

このような動作は、[ProviderListener] Widgetを使用して実装されます。

```dart
Widget build(BuildContext context) {
  return ProviderListener<StateController<int>>(
    provider: counterProvider,
    onChange: (context, counter) {
      if (counter.state == 5) {
        showDialog(...);
      }
    },
    child: Whatever(),
  );
}
```

これにより、カウンターが5に達したときにダイアログが表示されます。

## プロバイダの中で別のプロバイダをreadする

プロバイダーを作る際によくあるのが、他のオブジェクトからオブジェクトを作りたいというケースです。 

例えば、`UserRepository`から`UserController`を作成したい場合、  
両方のオブジェクトは別のプロバイダで公開されます。

このようなシナリオは、プロバイダがパラメータとして受け取る `ref` オブジェクトを使用することで可能になります。

```dart
final userRepositoryProvider = Provider((ref) => UserRepository());

final userControllerProvider = StateNotifierProvider((ref) {
  return UserController(
    // userRepositoryProviderをreadし、その結果からUserControllerを作成します。
    repository: ref.watch(userRepositoryProvider),
  );
});
```

[Combining Providers(プロバイダーの組み合わせ)](/docs/concepts/combining_providers)のガイドには、  
以下のような情報が掲載されていますので、ぜひご覧ください。

- 時間の経過とともに変化する値からオブジェクトを作成するとどうなるか？
- いくつかのグッドプラクティス

## Dartのみの場合のプロバイダ外のプロバイダのread

場合によっては、Flutterに依存していないパッケージのプロバイダをreadしたいこともあるでしょう。   
よくあるケースは、Widgetとは関係のないクラスをテストする場合です。

このような状況では、プロバイダを操作するための低レベルのユーティリティである[ProviderContainer]を使用することができます。

次のスニペットは、Flutterを使わずにテストでプロバイダをreadする方法を示しています。

```dart
test('counter starts at 0', () {
  final container = ProviderContainer();

  StateController<int> counter = container.read(counterProvider);
  expect(counter.state, 0);
});
```

:::danger
[ProviderContainer]のインスタンスをテスト間で再利用しないでください。 
これにより、テストケース間でプロバイダの状態が適切にリセットされるようになります。
:::

[provider]: https://pub.dev/documentation/riverpod/latest/riverpod/Provider-class.html
[stateprovider]: https://pub.dev/documentation/riverpod/latest/riverpod/StateProvider-class.html
[providercontainer]: https://pub.dev/documentation/riverpod/latest/riverpod/ProviderContainer-class.html
[providerlistener]: https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/ProviderListener-class.html
[providerscope]: https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/ProviderScope-class.html
[consumer]: https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/Consumer-class.html
[consumerwidget]: https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/ConsumerWidget-class.html
[useprovider]: https://pub.dev/documentation/hooks_riverpod/latest/hooks_riverpod/ref.watch(.html
[elevatedbutton]: https://api.flutter.dev/flutter/material/ElevatedButton-class.html
[streambuilder]: https://api.flutter.dev/flutter/widgets/StreamBuilder-class.html
[riverpod]: https://github.com/rrousselgit/river_pod
[text]: https://api.flutter.dev/flutter/widgets/Text-class.html
[hooks_riverpod]: https://pub.dev/packages/hooks_riverpod
[flutter_riverpod]: https://pub.dev/packages/flutter_riverpod
[flutter_hooks]: https://github.com/rrousselGit/flutter_hooks
[statenotifierprovider]: https://pub.dev/documentation/riverpod/latest/riverpod/StateNotifierProvider-class.html
[statenotifier]: https://pub.dev/documentation/state_notifier/latest/state_notifier/StateNotifier-class.html
[streamprovider]: https://pub.dev/documentation/riverpod/latest/riverpod/StreamProvider-class.html
